using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ZbAppleBinWav
{
    // see http://adtpro.cvs.sourceforge.net/viewvc/adtpro/adtpro/org/adtpro/transport/audio/
    // see http://stackoverflow.com/questions/22062521/c-sharp-equivalent-for-bytearrayoutputstream-in-java

    // see http://support.apple.com/kb/TA29964?viewlocale=en_US
    // see http://support.apple.com/kb/TA40730
    // see http://support.apple.com/kb/TA40737
    // see http://www.loomcom.com/blog/category/retrocomputing/retrochallenge/retrochallenge2013ww/
    // see http://www.pagetable.com/?p=32

    class BytesToWav
    {
        public static byte[] Encode(byte[] data, int length)
        {
            const int defaultHeaderLength = 4; // seconds
            return Encode(data, length, defaultHeaderLength); // was 300?
        }

        public static byte[] Encode(byte[] data, int length, int headerLength)
        {
            byte checksum = 0xFF; // -1; // java byte is signed

            var ms = new MemoryStream();
            var writer = new BinaryWriter(ms);
            //java.io.ByteArrayOutputStream payload = new java.io.ByteArrayOutputStream(1024 * 1024);

            WriteHeader(writer, SampleFreq, headerLength);
            WriteSync(writer, SampleFreq);

            checksum = WriteBytes(writer, SampleFreq, data, length, checksum);
            WriteByte(writer, SampleFreq, checksum, 0.0);
            Debug.WriteLine("checksum {0:F2}", checksum);

            WriteOnePeriod(writer, SampleFreq, EndFreq, 0.0);
            WriteSilence(writer, SampleFreq, 4); // 4 seconds

            return ms.ToArray();

            //java.io.ByteArrayOutputStream wholeFrigginThing = new java.io.ByteArrayOutputStream(44 + payload.size());
            //try
            //{
            //    wholeFrigginThing.write(payload.toByteArray());
            //}
            //catch (IOException e)
            //{
            //    Log.printStackTrace(e);
            //}
            //return wholeFrigginThing.toByteArray();
        }

        // write header
        // duration in seconds
        // "The header consists of 10 seconds of 770 Hz tone."
        static void WriteHeader(BinaryWriter writer, int sampleFrequency, int duration)
        {
            // how many periods do we need?
            // one period is (1 / HeaderFrequency) long
            // so, divide

            var periods = duration * HeaderFrequency;

            for (var i = 0; i < periods; i++)
            {
                // one period at HeaderFrequency
                WriteOnePeriod(writer, sampleFrequency, HeaderFrequency, 0.0);
            }
        }

        // sync bit
        // "The synchronous bit, generated by HEADR, is one half cycle of 2500 Hz, (200
        // microseconds) and one half cycle of 2000 Hz, (250 microseconds)."
        static void WriteSync(BinaryWriter writer, int sampleFrequency)
        {
            WriteOnePeriod(writer, sampleFrequency, BeginFreq, 0.0);
        }

        // write some silence
        // duration in seconds
        static void WriteSilence(BinaryWriter writer, int sampleFrequency, int duration)
        {
            var periods = duration * sampleFrequency;

            const byte zero = 0;
            for (var i = 0; i < periods; i++)
            {
                writer.Write(zero);
            }
        }

        // writes one period at frequency
        // ie half period at zero/low, half period at 1/high
        static double WriteOnePeriod(BinaryWriter writer, int sampleFrequency, int frequency, double inRemainder)
        {
            // one sample represents (1 / sampleFrequency) seconds
            // number of samples for 1 period is (sampleFrequency / frequency)
            // first half is down (0) second half is up (1)
            // so each half needs numBytes bytes

            // remainder takes care of periods shifts

            var numBytes = sampleFrequency / (2 * frequency);
            var remainder = inRemainder + (sampleFrequency / (double)(2 * frequency) - numBytes) / 20;
            byte value = 0; // 1;
            int i;
            for (i = 0; i < numBytes; i++)
            {
                writer.Write(value);
            }
            if (remainder > 1.0)
            {
                writer.Write(value);
            }
            value = 0xFF; // -1; // java byte is signed
            for (i = 0; i < numBytes; i++)
            {
                writer.Write(value);
            }
            if (remainder > 1.0)
            {
                writer.Write(value);
                remainder -= 1.0;
            }
            return remainder;
        }

        public static byte WriteBytes(BinaryWriter writer, int sampleFrequency, byte[] data, int length, byte checksum)
        {
            var remainder = 0.0;
            for (var i = 0; i < length; i++)
            {
                checksum = (byte) (data[i] ^ checksum);
                remainder = WriteByte(writer, sampleFrequency, data[i], remainder);
            }
            return checksum;
        }

        static double WriteByte(BinaryWriter writer, int sampleFrequency, byte data, double inRemainder)
        {
            var remainder = inRemainder;

            // for each 8 bits
            for (var j = 0; j < 8; j++)
            {
                var freq = (data & 0x00000080L) == 0x00000080L ? OneFreq : ZeroFreq;
                remainder = WriteOnePeriod(writer, sampleFrequency, freq, remainder);
                data = (byte) ((data << 1) & 0x000000FFL);
            }
            return remainder;
        }

        public const int SampleFreq = 44100;
        public const int HeaderFrequency = 770;
        public const int OneFreq = 1000;
        public const int ZeroFreq = 2000;
        public const int BeginFreq = 2200;
        public const int EndFreq = 200;
    }
}
